# 자료구조
### JVM이 정확히 무엇이고, 어떤 기능을 하는지 설명해 주세요.
<details>
<summary></summary>
<div>

## 1. JVM의 정의
- **Java Virtual Machine(JVM)**이란 자바 바이트코드(bytecode)를 실행하기 위한 **가상 컴퓨터(추상화된 컴퓨팅 플랫폼)**입니다.  
- 자바 컴파일러(`javac`)가 생성한 `.class` 파일(바이트코드)을 입력으로 받아, 실제 머신(운영체제·하드웨어)에서 동작할 수 있도록 해석·실행합니다.  
- JVM은 **‘한 번 컴파일하면 어디서나 실행된다(Write Once, Run Anywhere)’**는 자바 플랫폼의 핵심을 가능하게 하는 핵심 요소입니다.

## 2. JVM의 주요 구성 요소
1. **클래스 로더(Class Loader)**  
   - `.class` 파일을 읽어 메모리에 올리고, 내부 데이터 구조로 변환(링크)합니다.  
   - 사용자 정의 클래스뿐 아니라 런타임 라이브러리(예: `java.lang.*`)도 모두 이 서브시스템을 통해 로드됩니다.
2. **런타임 데이터 영역(Runtime Data Areas)**  
   - **메소드 영역(Method Area)**: 클래스·인터페이스의 런타임 상수 풀, 필드·메소드 정보 저장  
   - **힙(Heap)**: 객체 및 배열 인스턴스들이 생성되는 공간  
   - **스택(Stack)**: 각 스레드별로 JVM 호출 스택을 유지(메소드 호출 시마다 프레임 생성)  
   - **프로그램 카운터(PC) 레지스터**: 각 스레드가 현재 실행 중인 바이트코드의 주소를 가리킴  
   - **네이티브 메소드 스택(Native Method Stack)**: 자바 외 언어(C/C++ 등)로 작성된 네이티브 메소드 호출 시 사용
3. **실행 엔진(Execution Engine)**  
   - **인터프리터(Interpreter)**: 바이트코드를 한 줄씩 해석하며 실행  
   - **JIT 컴파일러(Just-In-Time Compiler)**: 반복적으로 호출되는 바이트코드를 네이티브 머신 코드로 번역해 **성능을 최적화**  
4. **가비지 컬렉터(Garbage Collector, GC)**  
   - 더 이상 참조되지 않는 객체를 탐지해 자동으로 메모리를 회수  
   - 메모리 누수를 방지하고, 명시적 메모리 해제 없이 안전한 실행 환경 제공  
5. **네이티브 인터페이스(Java Native Interface, JNI)**  
   - 자바 애플리케이션에서 C/C++ 등의 네이티브 코드를 호출할 수 있게 해 주는 브릿지 역할

## 3. JVM의 주요 기능
- **플랫폼 독립성 보장**  
  자바 바이트코드는 특정 하드웨어나 OS에 종속되지 않으므로, 동일한 `.class` 파일을 Windows·macOS·Linux 등 다양한 환경에서 실행 가능
- **메모리 관리 및 자동 가비지 컬렉션**  
  개발자가 명시적으로 메모리를 해제하지 않아도, JVM이 필요 시점에 객체를 정리하여 안정적인 메모리 운영
- **성능 최적화**  
  JIT 컴파일러를 통해 런타임에 핫스팟(빈번히 호출되는 코드)을 네이티브 코드로 변환, 반복 실행 시 성능 향상
- **보안 관리**  
  바이트코드 검증(bytecode verifier)을 통해 악의적인 코드 삽입을 방지하고, 클래스 로더·보안 매니저를 통해 실행 권한을 제어
- **멀티스레드 스케줄링 지원**  
  JVM 내부에서 스레드별 호출 스택과 PC 레지스터를 관리하여, 자바 레벨의 스레드 동시 실행 및 동기화 제공

## 4. JVM의 동작 과정 요약
1. **소스 코드(.java) → 바이트코드(.class) 컴파일**  
2. **클래스 로더**가 `.class` 파일 로드 및 링크  
3. **바이트코드 검증** (안전성·무결성 검사)  
4. **인터프리터** 또는 **JIT 컴파일러**를 통해 바이트코드 실행  
5. **런타임 데이터 영역**에서 객체 생성 및 메모리 관리  
6. **가비지 컬렉터**가 주기적으로 불필요 객체 회수

## 5. JVM의 이점
- **이식성**: 한번 작성한 코드를 다양한 플랫폼에서 실행  
- **안정성**: 메모리 안전성 및 보안 메커니즘 내장  
- **관리 용이성**: 자동 메모리 관리, 모니터링·디버깅 도구 제공  
- **확장성**: 다양한 가비지 컬렉터(G1, ZGC 등)와 최적화 기법 선택 가능  

---

이와 같이 JVM은 자바 프로그램을 실행하기 위한 **추상화된 런타임 환경**으로, 바이트코드를 플랫폼 독립적으로 해석·컴파일하고, 메모리·스레드·보안을 종합적으로 관리함으로써 자바의 핵심 가치인 “이식성·안정성·성능”을 실현합니다.
</div>
</details>
<details>
<summary>그럼, 자바 말고 다른 언어는 JVM 위에 올릴 수 없나요?</summary>
<div>

JVM은 ‘바이트코드(​.class)’를 실행하는 가상 머신이기 때문에, **바이트코드를 생성할 수 있는(any language compiler)를 JVM 타깃으로 삼기만 하면** 자바뿐 아니라 어떤 언어도 올릴 수 있습니다. 실제로 다음과 같은 언어들이 JVM 위에서 동작합니다:

- **Kotlin**  
  JetBrains에서 만든 정적 타입 언어로, 자바와 100% 상호 운용(interoperability) 가능  
- **Scala**  
  함수형·객체지향을 결합한 언어로, 병렬·비동기 프로그래밍에 강점  
- **Groovy**  
  동적 스크립트 언어로, 자바 문법과 호환되며 빌드 스크립트·테스트 코드 등에 자주 사용  
- **Clojure**  
  JVM 기반의 함수형 리스프(Lisp) 언어, 불변 자료구조·병렬 처리 모델 제공  
- **JRuby**  
  루비(Ruby) 언어를 JVM 위에서 실행할 수 있게 옮긴 구현체  
- **Jython**  
  파이썬(Python) 2.x 계열을 JVM 위에서 실행할 수 있는 구현체  
- **Ceylon, Fantom, Xtend, Gosu, Frege** 등  
  각각 고유의 문법과 특성을 가진 언어들이 JVM 타깃을 지원  

---

## 어떻게 가능할까?
1. **컴파일러 플러그인/백엔드**  
   - 언어의 컴파일러가 최종 산출물을 JVM 바이트코드로 생성하도록 백엔드를 구현  
   - 예: Kotlin 컴파일러, Scala 컴파일러, Groovy 컴파일러 등  
2. **인터프리터 방식**  
   - 순수 자바(Java) 코드로 해당 언어의 인터프리터를 작성하고, JVM에서 직접 해석  
   - 예: JRuby, Jython  
3. **JSR-292 (invokedynamic) 지원**  
   - 자바 7부터 도입된 `invokedynamic` 바이트코드 명령어로 동적 언어를 더 효율적으로 구현  

이처럼 JVM은 **언어 독립적인 런타임 플랫폼**으로 설계되어 있기 때문에, “JVM 타깃 코드(바이트코드)만 만들 수 있느냐”가 관건입니다. 자바가 아니어도, 자신만의 문법·타입 시스템을 가진 언어라도 바이트코드를 생산할 수 있다면 JVM 위에서 실행시킬 수 있습니다.
</div>
</details>
<details>
<summary></summary>
<div>

</div>
</details>