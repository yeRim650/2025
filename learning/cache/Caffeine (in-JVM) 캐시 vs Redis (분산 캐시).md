### Caffeine (in-JVM local cache) vs Redis (clustered remote cache)

| 구분               | **Caffeine**<br>(동일 JVM 내부)                                           | **Redis**<br>(네트워크 분산 캐시)                                                            |
| ---------------- | --------------------------------------------------------------------- | ------------------------------------------------------------------------------------ |
| **지연 (latency)** | 마이크로초(μs) 단위. GC 영역 안이므로 네트워크 비용 0                                    | RTT + 직렬화. 보통 0.2 \~ 1 ms (동일 AZ), 멀티 AZ/Site는 수 ms                                  |
| **스루풋**          | CPU·메모리 선에서 JVM 한계까지 수백만 QPS                                          | 싱글 스레드 ↔ 파이프라이닝/클러스터 분산으로 수십만 \~ 수백만 QPS                                             |
| **데이터 일관성 범위**   | **프로세스-스코프**. 동일 인스턴스만 공유                                             | 모든 노드(다중 서비스) 간 공유. 멀티 AZ 복제/퍼시스턴스 지원                                                |
| **장애 전파**        | 애플리케이션 프로세스 죽으면 캐시 삭제                                                 | Redis 장애 시 모든 인스턴스 동시에 미스(but Sentinel/Cluster로 HA)                                  |
| **무효화 방법**       | JVM 안에서 직접 메서드 호출 (`cache.invalidate(id)`)                            | Pub/Sub, keyspace-event, 버전키 등 **네트워크 기반**                                           |
| **TTL·만료 정확도**   | nanosecond 단위까지 정확                                                    | 초 단위(0.1-sec precision). 클러스터마다 drift 존재                                             |
| **메모리 비용**       | 각 인스턴스마다 **중복 메모리**                                                   | 한 곳에 집중(Replica 포함). Hot key 중복 저장 X                                                 |
| **GC 영향**        | Large heap → GC pause 위험. Caffeine은 Soft/Weak/EH 성능 최적화               | Redis 자체 메모리 관리 (jemalloc). GC 이슈 없음                                                 |
| **배포‧운영**        | 라이브러리 ⟶ jar 추가 끝                                                      | 별도 인프라, 모니터링, 버전 업그레이드, 보안 패치 필요                                                     |
| **확장 전략**        | 인스턴스 더 띄우면 각자 독립 캐시 → **파편화**                                         | 샤딩/Cluster 로 선형 확장. 동시성 높은 전역 데이터를 캐시                                                |
| **보안**           | 프로세스 외부 노출 X (JVM 내부)                                                 | TLS, ACL, VPC 격리 권장. 퍼블릭 노출 땐 위험                                                     |
| **적합한 데이터**      | - 고빈도 read & per-request 강 일관성<br>- 세션·구동 중 계산 결과<br>- 작은 객체 (< 1 MB) | - 다중 인스턴스가 공유해야 할 상태<br>- Hot key, 공용 토큰, 피쳐플래그<br>- 캐시외에도 MQ/PubSub·락 등 Redis 기능 활용 |

---

## 언제 Caffeine만으로 충분한가?

1. **Stateless 애플리케이션**이지만 *같은 인스턴스 내* 연속 요청이 많은 API
   (ex. GraphQL 변환 캐시, 요청 체인 내 메서드 간 중복 DB 조회 방지)
2. **읽기 패턴이 사용자-인스턴스 국한**
   (ex. WebSocket-단일 연결 세션 정보)
3. **네트워크 Hop 한 번이라도 줄이는 것이 p99 응답의 핵심**
   (슬래시커트처럼 μs\~ms 차이로 SLA 결정될 때)
4. **메모리가 남아돌고 인스턴스 수가 적은 초기 단계 스타트업**

---

## Redis가 필요한 순간

| 시나리오                              | 설명                          |
| --------------------------------- | --------------------------- |
| **다중 인스턴스 간 공유 상태**               | 로그인 세션, 액세스 토큰, 레이트-리미터 카운터 |
| **Pub/Sub·Stream 등 부가 기능**        | 채팅, 실시간 알림, 비동기 워크플로 조율     |
| **캐시 크기 > 단일 애플리케이션 heap**        | 이미지 썸네일, 수백 MB 이상 룩업 테이블    |
| **즉시 무효화**를 모든 인스턴스에 전파           | 관리자 권한 변경, 기능 플래그 rollout   |
| **Blue/Green 배포**에서 버전-별 캐시 격리 필요 | `user:{v}` 패턴으로 버전키 관리      |

---

## 하이브리드 2-계층 패턴

```
[애플리케이션 JVM] → L1: Caffeine (수 μs)
                  ↘ miss
                    L2: Redis (수 100 μs ~ 1 ms) ↔ DB
```

1. **로컬 히트율 80 % 이상** 확보 → p99 크게 향상.
2. `user:123` 키 기준:   Caffeine TTL 1 s, Redis TTL 30 s 처럼 계층별 TTL 차등.
3. Redis keyspace-event 로 `invalidate(user:123)` Pub/Sub → 각 JVM `Caffeine.invalidate()`.

> Netflix, Pinterest, Kakao 같은 대규모 트래픽 서비스가 채택한 전형적 구조.

---

## 의사결정 체크리스트

1. **공유 범위가 인스턴스 내부냐, 서비스 전역이냐?**
2. **캐시 미스 시 허용 가능한 지연**은? (μs vs ms)
3. **데이터 신선도 요구** (권한·잔액 같이 즉시 반영?)
4. **캐시 데이터 셋 크기와 중복 메모리** 부담은?
5. **운영 복잡도** – Redis 클러스터 운영할 팀 역량·리소스?
6. **추가 Redis 기능**(분산락, Pub/Sub, Streams)이 향후 필요할까?

---

### 결론

* **한 인스턴스당 hit → μs** 수준으로 줄이고 싶다면 **Caffeine**이 가장 빠르고 단순합니다.
* **여러 인스턴스가 동일 데이터를 읽고, 실시간 무효화가 필요**하다면 **Redis**가 필수입니다.
* **대부분의 대규모 서비스**는 **Caffeine L1 + Redis L2** 2계층으로 “속도와 일관성”을 동시에 확보합니다.

> *“캐시는 도구일 뿐, 데이터 일관성·운영 복잡도·비용을 함께 고려한 균형이 해답”*
