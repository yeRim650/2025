# bulkInsert 메서드 분석 및 최적화 제안 — 리뷰

## 📌 1. 현재 `bulkInsert` 메서드 분석

### 1.1 트랜잭션 처리
- `@Transactional`으로 한 번에 묶어 일관성 보장은 매우 중요합니다.
- 대용량 처리 시 단일 트랜잭션이 오래 유지되면 DB 락 경합이 발생할 수 있으므로, 청크 단위로 트랜잭션을 분리하거나 적절한 격리 수준을 검토하세요.
- 예외 발생 시 전체 롤백은 안전하지만, 실패 건만 재시도하는 부분 롤백 전략을 도입하면 처리 안정성이 더욱 높아집니다.

### 1.2 MERGE INTO SQL 사용
- `MERGE` 문으로 INSERT/UPDATE를 한 번에 처리하는 접근은 효율적이지만, Oracle에서는 실행 계획에 따라 전체 테이블 스캔이나 락 확대가 발생할 수 있습니다.
- `HTML_ID` 컬럼에 인덱스가 반드시 존재하고 통계가 최신인지 주기적으로 점검하세요.
- 대규모 MERGE 시 ORA-30926(일관성 위반) 오류에 대비해, 실행 전 입력 데이터 내 중복 키를 사전 검증하는 로직을 추가하면 좋습니다.

### 1.3 데이터 변환 처리
- SQL `CASE WHEN` 구문으로 비즈니스 로직을 직접 구현하면 SQL이 복잡해지고, 규칙 변경 시 유지보수가 어려워집니다.
- Java 레이어에서 Enum 또는 Map 기반으로 변환을 수행한 뒤, 순수한 MERGE 문을 실행하는 것이 가독성과 테스트 커버리지 측면에서 유리합니다.

### 1.4 대용량 텍스트 처리 (CLOB)
- `setNClobIfNotNull`과 `StringReader` 조합은 안정적이지만, 수십 MB 이상의 CLOB은 메모리 부하가 큽니다.
- 가능하다면 `InputStream` 기반 스트리밍으로 대체하거나, 별도 파일 스토리지 연동을 검토해 보세요.

### 1.5 배치 처리 최적화
- `batchUpdate()`로 1,000건씩 묶어 처리하는 것은 표준적이지만, 실제 최적 배치 사이즈는 네트워크 레이턴시와 DB 부하를 고려해 부하 테스트를 통해 도출해야 합니다.
- JDBC 드라이버 옵션(`rewriteBatchedStatements=true` 등)이 활성화되어 있는지 확인하고, 예외 발생 시 어떤 레코드가 문제인지 로깅 체계를 강화하세요.

### 1.6 NULL 데이터 처리
- NULL 안정성을 확보하기 위해 개별 필드별 `if-null` 처리가 분산되어 있지만, 중복 코드를 줄이기 위해 공통 유틸 메서드나 Optional 체인을 활용해 가독성을 높이고 유지보수를 단순화하세요.

---

## 🚀 2. 개선 가능한 `bulkInsert` 방법

### 2.1 Spring Batch 활용
- 대용량·대규모 스케줄 작업에 특화된 프레임워크로, 장애 복구(restart)·retry 정책 구성이 편리합니다.
- 다만 설정과 인프라(스프링 컨텍스트, Job Repository)가 추가되므로, 단발성 배치라면 도입 비용을 따져보세요.

### 2.2 JDBC Batch Update 최적화
- 드라이버 레벨에서 `rewriteBatchedStatements=true` 등을 활성화하면 네트워크 왕복 횟수를 크게 줄일 수 있습니다.
- 배치 사이즈는 500~2,000건 사이에서 부하 테스트를 통해 최적값을 찾으세요.

### 2.3 NamedParameterJdbcTemplate 사용
- 파라미터 이름 기반 바인딩으로 가독성과 유지보수성이 개선됩니다.
- 필드가 많거나 Optional 파라미터가 많을 때 Null 처리 로직이 간결해지는 장점이 있습니다.

### 2.4 SQL 분할 처리 (청크링)
- 대량 데이터를 메모리 오버플로 없이 처리하려면 1,000건 단위 이상의 청크 분할을 적용하세요.
- 트랜잭션 단위가 작아지면 락 보유 기간도 짧아져 전체 시스템 안정성이 높아집니다.

### 2.5 영속성 컨텍스트 최적화 (JPA 사용 시)
- JPA로 처리할 경우 `EntityManager.flush()`와 `clear()`를 주기적으로 호출하면 영속성 컨텍스트 메모리를 해소할 수 있습니다.
- 다만 JDBC 기반 코드와 혼용하면 트랜잭션 경계가 모호해질 수 있으니, 한 가지 전략을 선택해 일관되게 운영하세요.

### 2.6 물리적 분할 처리 (병렬)
- `CompletableFuture`나 스레드 풀을 통해 I/O·CPU를 병렬 활용할 수 있지만, DB 커넥션 풀 소진이나 락 경합에 주의해야 합니다.
- 병렬성 수준(concurrency level)을 소규모로 시작해 점진적으로 늘리며 모니터링하세요.

### 2.7 변환 로직을 Java로 이전
- 변환 규칙을 Java로 이관하면 SQL이 단순해지고 단위 테스트 작성이 쉬워집니다.
- 다만 DB 뷰 등에 의존적인 규칙이 있으면 DB 측 로직을 유지하는 편이 유리할 수 있으니, 케이스별로 비교 검토하세요.

---

## ✅ 결론 및 권장 전략

| 항목            | 현재 방식                  | 개선 제안                                       |
| -------------- | ------------------------- | ---------------------------------------------- |
| **SQL 복잡도**   | MERGE + CASE WHEN          | MERGE 단순화 + Java 변환 로직 분리                 |
| **성능 최적화**  | batchUpdate(1,000건)       | 드라이버 옵션 활성화 + 배치 사이즈 튜닝, 필요 시 Spring Batch |
| **대용량 텍스트** | setNClob + StringReader    | InputStream 스트리밍 또는 파일 스토리지 연동        |
| **트랜잭션 처리** | 단일 트랜잭션               | 청크 단위 분리, 병렬 처리 시 락 경합 관리           |
| **유지보수성**   | 필드별 NULL 처리 분산       | NamedParameterJdbcTemplate + 공통 유틸 메서드 활용   |

---

**종합 제언:**
1. JDBC 배치 + Java 변환 로직 프로토타입 검증
2. 성능 병목 확인 후 Spring Batch 도입 검토
3. APM·메트릭 기반 모니터링으로 실제 부하 가시화
4. 리팩토링과 함께 통합 및 부하 테스트 병행
